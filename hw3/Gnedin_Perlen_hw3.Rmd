---
title: "FIN580_HW3"
output: pdf_document
---

#installing needed packages
```{r, warning=FALSE,tidy=TRUE, message=FALSE }
#Setup 
library(gridExtra)
library(e1071)
library(lubridate)
library(tidyverse)
library(gridExtra)
library(xlsx)
library(forecast)
library(tseries)
library(stats)
library(car)
library(glmnet)
library(miscTools)
library(Metrics)
library(knitr)
library(class)
library(vars)
library(stargazer)
library(BigVAR)
library(orderedLasso)
library(BioPhysConnectoR)

#Set seed
set.seed(1560)

```

---

Reading in and preprocessing data
```{r, warning=FALSE,tidy=TRUE, message=FALSE }

#setwd("~/Desktop/FIN580/data")
setwd("~/Desktop/Grad_School/2016-2017_Spring/Amin/Homework/HW_3/FIN580/data") #Nina's
load_data_from_scratch = T

if(load_data_from_scratch){
  file_names=dir(path="~/Desktop/FIN580/data",pattern = '.csv')
  currencies = strsplit(file_names[1:(length(file_names)-1)],'USD.csv')
  labels = read.csv(file_names[length(file_names)],header = T)
  labels[,1] = as.Date(labels[,1], origin = lubridate::origin )
  labels[nrow(labels),2] = 0 #not training on last day because do not have data to test fit
  colnames(labels)[1] = "Date"
  
  prices = lapply(file_names[1:length(currencies)], function(x) { 
    temp = read.csv(x ,header = T)
    temp = temp[,c("Date","Close")]
    if(x == "AUDUSD.csv"){
      temp$Date = as.Date(temp$Date, format = "%m/%d/%y",origin = lubridate::origin) #why it has a different format I have no idea
    }
    else{
      temp$Date = as.Date(temp$Date, format = "%m/%d/%Y",origin = lubridate::origin)
    }
    return(temp) })
  
  names(prices) = currencies
  dates = unique(labels[,1])
  
  #compute return series
  get_5min_rets = function(x){
    tot_rets = data.frame(Date=as.Date(character()), Returns = numeric())
    pos = 1
    for(i in 1:length(dates)){
      indicies = which(x[,1] == dates[i])
      if(length(indicies) != 0){
        
        daily_prices = x[indicies,2]
        daily_rets = log(daily_prices[2:length(daily_prices)]/daily_prices[1:(length(daily_prices)-1)])
        len = length(daily_rets)
        tot_rets[pos:(pos+len-1),] = list(rep(dates[i],length(daily_rets)),daily_rets)
        pos = pos + len
      }
    }
    return(tot_rets)
  }
  
  rets_5min = lapply(prices, get_5min_rets)
  
  get_daily_rets = function(x){
    rets = data.frame(Date=as.Date(character()), Ret = numeric(), Train = numeric() )
    pos = 1
    for(i in 1:length(dates)){
      indicies = which(x[,1] == dates[i])
      len = length(indicies)
      if(len != 0){
        ret = log(x[indicies[len],2]/x[indicies[1],2]) #return for the day is log(P_23:55/P_0:00)
        rets[pos,] = list(dates[i],ret, labels[which(labels$Date == dates[i]),2])
        pos = pos + 1
      }
    }
    return(rets)
  }
  
  daily_rets = lapply(prices, get_daily_rets)
  
  
  
  #compute volatility series
  
  get_daily_vols = function(x){
    
    vols = data.frame(Date=as.Date(character()), Vol = numeric(), Train = numeric() )
    pos = 1
    for(i in 1:length(dates)){
      indicies = which(x[,1] == dates[i])
      if(length(indicies) != 0){
        rets = x[indicies,2]
        vol = sqrt(252) * sd(rets) #annualize volatility
        if(vol != 0){ #get rid of days during which vol is 0
          vols[pos,] = list(dates[i],log(vol), labels[which(labels$Date == dates[i]),2])
          pos = pos + 1
        }
      }
    }
    return(vols)
  }
  
  daily_vols = lapply(rets_5min,get_daily_vols)
  
  
  #weekly statics
  dates_by_curr = lapply(daily_vols, function(x){ x$Date}) #which dates have non-zero vols
  
  
  
  get_weekly_vols = function(curr){
    x = rets_5min[[curr]]
    c_dates = dates_by_curr[[curr]]
    
    vols = data.frame(Date=as.Date(character()), Ret = numeric(), Train = numeric() )
    pos = 1
    for(i in 5:length(c_dates)){
      indicies = unique(unlist(sapply((i-4):i, function(j) { which(x[,1] == c_dates[j])})))
      if(length(indicies) != 0){
        rets = x[indicies,2]
        vol = sqrt(50) * sd(rets) #annualize volatility
        if(vol != 0){ #get rid of days during which vol is 0
          vols[pos,] = list(c_dates[i],log(vol), labels[which(labels$Date == c_dates[i]),2])
          pos = pos + 1
        }
      }
    }
    return(vols)
  }
  
  weekly_vols = lapply(currencies, get_weekly_vols)
  names(weekly_vols) = currencies
  
  
  
  get_weekly_rets = function(curr){
    x = prices[[curr]]
    c_dates = dates_by_curr[[curr]]
    
    rets = data.frame(Date=as.Date(character()), Ret = numeric(), Train = numeric() )
    pos = 1
    for(i in 5:length(c_dates)){
      indicies = unique(unlist(sapply((i-4):i, function(j) { which(x[,1] == c_dates[j])})))
      n = length(indicies)
      if(n != 0){
        ret = log(x[indicies[n],2] / x[indicies[1],2] )#last day close divided first day open
        rets[pos,] = list(c_dates[i],ret, labels[which(labels$Date == c_dates[i]),2]) 
        pos = pos + 1
      }
    }
    return(rets)
  }
  
  weekly_rets = lapply(currencies, get_weekly_rets)
  names(weekly_rets) = currencies
  
  save(weekly_rets, file = "weekly_rets.Rdata")
  save(daily_rets,file = "daily_rets.Rdata")
  save(daily_vols,file="daily_vols.RData")
  save(weekly_vols,file="weekly_vols.RData")
  save(currencies, file = "currencies.RData")
}

if(!load_data_from_scratch)  {
  load("daily_vols.RData")
  load("weekly_vols.RData")
  load("daily_rets.RData")
  load("weekly_rets.RData")
  load("currencies.RData")
}

#Get ylabels to be used throughout


```










#Support Vector Machine implementation
Preprocess data
```{r,tidy=TRUE,warning=FALSE}

append_target = function(ts){
  for(curr in currencies){
    temp = ts[[curr]]
    len = nrow(ts[[curr]])
    ts[[curr]] = ts[[curr]][1:(len-1),]
    ts[[curr]] [,'Target'] = temp[2:len,2] 
  }
  return(ts)
}

append_ret = function(ts,rets){
  for(curr in currencies){
    dates = ts[[curr]]$Date
    ret = rets[[curr]]
    pos = 1
    for(d in dates){
      lookup = which(ret[,1]== as.Date(d,lubridate::origin))
      ts[[curr]][pos,'Ret'] = ret$Ret[lookup]
      pos = pos + 1
    }
  }
  return(ts)
}


daily_data = append_target(daily_vols)
weekly_data = append_target(weekly_vols)
daily_data = append_ret(daily_data,daily_rets)
weekly_data = append_ret(weekly_data,weekly_rets)

```


Linear SVM Helper Functions
```{r,tidy=TRUE,warning=FALSE}

#helper functions
get_labels=function(ts,delta,index){
  lag = ts$Vol
  realized = ts$Target
  
  labels = sapply(index, function(i){ 
    plus_diff = abs(realized[i] - lag[i]*(1+delta))
    minus_diff = abs(realized[i] - lag[i]*(1-delta))
    if(minus_diff <= plus_diff){
      return(-1)
    }
    return(1)})
  return(labels)
}



#fits linear svm, inputs should be of form c('Vol','Ret','maVol','maRet') etc, where '' is any colname of data
svm_linear = function(data,inputs,delta){ 
  

  #splits into train and test
  train_indicies = which(data$Train == 1)
  test_indicies = which(data$Train == 0) 
  
  #generates model data sets for training and prediction
  train_labels = get_labels(data,delta,train_indicies) #codes +- 1
  y = as.factor(train_labels)
  
  x_train = vector("list", length(inputs))
  predictors = vector("list", length(inputs))
  names(x_train) = inputs
  names(predictors) = inputs
  
  for(input in inputs){
    x_train[[input]] = data[train_indicies,input]
    predictors[[input]] = data[test_indicies,input]
  }
  
  x_train = as.data.frame(x_train)
  predictors = as.data.frame(predictors)
  df = x_train
  df['Labels'] = y

#tune and fit svm 
  
  svm_model = svm(as.factor(df$Labels) ~., data=df) #faster to not tune, can tune in future
  #svm_tune = tune(svm, train.x= x_train, train.y= as.factor(df$Labels), kernel='linear', ranges=list(cost=10^(-1:1), gamma=c(.5,1,2)))
  #svm_model = svm(as.factor(df$Labels) ~ ., data=df,kernel='linear', cost = svm_tune$best.model$cost, gamma = svm_tune$best.model$gamma,type = "C-classification")
  
#svm to predict
  pred_test_labels = as.numeric(predict(svm_model, predictors))
  pred_test_labels[which(pred_test_labels == 1)] = -1 #outputs as factor so need to invert 
  pred_test_labels[which(pred_test_labels == 2)] = 1
  realized_labels = get_labels(data,delta,test_indicies)
  acc = length(which(pred_test_labels == realized_labels))/length(pred_test_labels) #compute classification accuracy
  
    
  #regression model
  test_predictions = sapply(1:length(pred_test_labels), function(i) {
    if (pred_test_labels[i] == 1){
      return(data$Vol[test_indicies[i]] * (1 + delta)) 
    }
    else{
      return(data$Vol[test_indicies[i]] * (1 - delta)) 
    }
  })
  
  #return mse,acc
  return(c(mean( (test_predictions - data$Target[test_indicies])^2),acc))
}  


#plotting utility
plot_results = function(results,name_start){
  for(curr in currencies){
    indicies = which(results$Currency == curr)
    name = paste(name_start, 'MSE v Delta for Currency ', curr, sep = "")
    plot(results$Delta[indicies], results$MSE[indicies], xlab = 'Delta', ylab = 'mse',main = name, pch=21,  bg="blue")
    
    index = which.min(results$MSE[indicies])
    points(results$Delta[indicies[index]],results$MSE[indicies[index]] ,pch=21,  bg="red")
    
    dev.copy(pdf,paste(name,".pdf",sep=""))
    dev.off()
    
   name = paste(name_start, 'Accuracy v Delta for Currency ', curr, sep = "")
    plot(results$Delta[indicies], results$Accuracy[indicies], xlab = 'Delta', ylab = 'Accuracy',main = name, pch=21, bg="red")
    index = which.max(results$Accuracy[indicies])
    points(results$Delta[indicies[index]],results$Accuracy[indicies[index]] ,pch=21,  bg="blue")
    
    dev.copy(pdf,paste(name,".pdf",sep=""))
    dev.off()
  }
}

get_cummulative_statics = function(results){
  
  cum_mse = data.frame(Delta = numeric(), MSE = numeric())
  cum_acc = data.frame(Delta = numeric(), Accuracy = numeric())
  
  pos = 1
  for(delta in delta_grid){
    indicies = which(daily_1d_results$Delta == delta)
    cum_mse[pos,] = list(delta, sum(results$MSE[indicies]))
    cum_acc[pos,] = list(delta, mean(results$Accuracy[indicies]))
    pos = pos + 1
  }
  return(c(cum_mse,cum_acc))
}

```



run svm regression for linear predictor of daily data
```{r,tidy=TRUE,warning=FALSE}


delta_grid = seq(.001,.051,.05/20)
daily_1d_results = data.frame(Currency = character(), Delta = numeric(), MSE = numeric(), Accuracy = numeric(), stringsAsFactors = F)	


pos = 1
for(curr in currencies){
  for(delta in delta_grid){
    results = svm_linear(daily_data[[curr]],c('Vol'),delta)
    daily_1d_results[pos,] = list(curr,delta,results[1],results[2]) 
    pos = pos + 1
  }
}

#plotting
setwd("~/Desktop/FIN580/hw3/Plots/1D")  #directory where you want to print the plots
plot_results(daily_1d_results,'Linear 1-dim SVM Daily Vol ')


#cummulative results
temp = get_cummulative_statics(daily_1d_results)
daily_1d_cum_mse = as.data.frame(cbind(temp$Delta, temp$MSE))
names(daily_1d_cum_mse) = c('Delta','MSE')
daily_1d_cum_acc = as.data.frame(cbind(temp$Delta, temp$Accuracy))
names(daily_1d_cum_acc) = c('Delta','Accuracy')

rm(temp)


```




run svm regression for linear predictor of weekly data
```{r, tidy = T, warnings = F}

weekly_1d_results = data.frame(Currency = character(), Delta = numeric(), MSE = numeric(), Accuracy = numeric(), stringsAsFactors = F)	


pos = 1
for(curr in currencies){
  for(delta in delta_grid){
    results = svm_linear(weekly_data[[curr]],c('Vol'),delta)
    weekly_1d_results[pos,] = list(curr,delta,results[1],results[2]) 
    pos = pos + 1
  }
}

#plotting
plot_results(weekly_1d_results,'Linear 1-dim SVM Daily Vol ')


#cummulative results
temp = get_cummulative_statics(weekly_1d_results)
weekly_1d_cum_mse = as.data.frame(cbind(temp$Delta, temp$MSE))
names(weekly_1d_cum_mse) = c('Delta','MSE')
weekly_1d_cum_acc = as.data.frame(cbind(temp$Delta, temp$Accuracy))
names(weekly_1d_cum_acc) = c('Delta','Accuracy')

rm(temp)


```





#Two-dimensional SVM

Daily data
```{r,tidy=TRUE,warning=FALSE}

daily_2d_results = data.frame(Currency = character(), Delta = numeric(), MSE = numeric(), Accuracy = numeric(), stringsAsFactors = F)	

pos = 1
for(curr in currencies){
  for(delta in delta_grid){
    results = svm_linear(daily_data[[curr]],c('Vol','Ret'),delta)
    daily_2d_results[pos,] = list(curr,delta,results[1],results[2]) 
    pos = pos + 1
  }
}

#plotting
setwd("~/Desktop/FIN580/hw3/Plots/2D")  #directory where you want to print the plots
plot_results(daily_2d_results,'2-Dim SVM Daily Vol ')


#cummulative results
temp = get_cummulative_statics(daily_2d_results)
daily_2d_cum_mse = as.data.frame(cbind(temp$Delta, temp$MSE))
names(daily_2d_cum_mse) = c('Delta','MSE')
daily_2d_cum_acc = as.data.frame(cbind(temp$Delta, temp$Accuracy))
names(daily_2d_cum_acc) = c('Delta','Accuracy')

rm(temp)
```




Weekly data
```{r,tidy=TRUE,warning=FALSE}
weekly_2d_results = data.frame(Currency = character(), Delta = numeric(), MSE = numeric(), Accuracy = numeric(), stringsAsFactors = F)	

pos = 1
for(curr in currencies){
  for(delta in delta_grid){
    results = svm_linear(weekly_data[[curr]],c('Vol','Ret'),delta)
    weekly_2d_results[pos,] = list(curr,delta,results[1],results[2]) 
    pos = pos + 1
  }
}

#plotting
setwd("~/Desktop/FIN580/hw3/Plots/2D")  #directory where you want to print the plots
plot_results(weekly_2d_results,'2-Dim SVM Weekly Vol ')


#cummulative results
temp = get_cummulative_statics(weekly_2d_results)
weekly_2d_cum_mse = as.data.frame(cbind(temp$Delta, temp$MSE))
names(weekly_2d_cum_mse) = c('Delta','MSE')
weekly_2d_cum_acc = as.data.frame(cbind(temp$Delta, temp$Accuracy))
names(weekly_2d_cum_acc) = c('Delta','Accuracy')

rm(temp)

```




#Moving Average Volatility
```{r,tidy=TRUE,warning=FALSE}


#Helper function to compute E_p as defined in problem set


append_moving_avg = function(ts,p){
  m_avg = data.frame(Date=as.Date(character()), Vol = numeric(), Train = numeric(), Target = numeric(), Ret = numeric(), maVol = numeric(),  maRet = numeric())
  pos = 1
  for(i in p:(nrow(ts)-1)){
    avgVol = mean(ts[(i-p+1):i,'Vol'])
    avgRet = mean(ts[(i-p+1):i,'Ret'])
    m_avg[pos,] = list(as.Date(ts[i,'Date']), ts[i,'Vol'], ts[i,'Train'], ts[i,'Target'], ts[i,'Ret'], avgVol, avgRet)
    pos = pos + 1
  }
  return(m_avg)
}

```



Daily data

```{r,tidy=TRUE,warning=FALSE}
setwd("~/Desktop/FIN580/hw3/Plots/MA")

look_back = c(3,5,10)

daily_lookback_1d_mse = vector("list", length(currencies))
daily_lookback_1d_acc = vector("list", length(currencies))
names(daily_lookback_1d_mse) = currencies
names(daily_lookback_1d_acc) = currencies

for(curr in currencies){
  daily_lookback_1d_mse[[curr]] = matrix(nrow = length(look_back), ncol = length(delta_grid))
  daily_lookback_1d_acc[[curr]] = matrix(nrow = length(look_back), ncol = length(delta_grid))
  for(i in 1:length(look_back)){
    ts = append_moving_avg(daily_data[[curr]],look_back[i]) 
    for(j in 1:length(delta_grid)){
    results = svm_linear(ts,c('maVol'),delta_grid[j]) 
    daily_lookback_1d_mse[[curr]][i,j] = results[1]
    daily_lookback_1d_acc[[curr]][i,j] = results[2]
    }
  }
}


```



Weekly data

```{r,tidy=TRUE,warning=FALSE}

weekly_lookback_1d_mse = vector("list", length(currencies))
weekly_lookback_1d_acc = vector("list", length(currencies))
names(weekly_lookback_1d_mse) = currencies
names(weekly_lookback_1d_acc) = currencies

for(curr in currencies){
  weekly_lookback_1d_mse[[curr]] = matrix(nrow = length(look_back), ncol = length(delta_grid))
  weekly_lookback_1d_acc[[curr]] = matrix(nrow = length(look_back), ncol = length(delta_grid))
  for(i in 1:length(look_back)){
    ts = append_moving_avg(weekly_data[[curr]],look_back[i]) 
    for(j in 1:length(delta_grid)){
    results = svm_linear(ts,c('maVol'),delta_grid[j]) 
    weekly_lookback_1d_mse[[curr]][i,j] = results[1]
    weekly_lookback_1d_acc[[curr]][i,j] = results[2]
    }
  }
}


```



#Moving Average : Two Dimensional

Daily data

```{r,tidy=TRUE,warning=FALSE}

look_back = c(3,5,10)

daily_lookback_2d_mse = vector("list", length(currencies))
daily_lookback_2d_acc = vector("list", length(currencies))
names(daily_lookback_1d_mse) = currencies
names(daily_lookback_1d_acc) = currencies

for(curr in currencies){
  daily_lookback_2d_mse[[curr]] = matrix(nrow = length(look_back), ncol = length(delta_grid))
  daily_lookback_2d_acc[[curr]] = matrix(nrow = length(look_back), ncol = length(delta_grid))
  for(i in 1:length(look_back)){
    ts = append_moving_avg(daily_data[[curr]],look_back[i]) 
    for(j in 1:length(delta_grid)){
    results = svm_linear(ts,c('maVol', 'maRet'),delta_grid[j]) 
    daily_lookback_2d_mse[[curr]][i,j] = results[1]
    daily_lookback_2d_acc[[curr]][i,j] = results[2]
    }
  }
}


```



Weekly data

```{r,tidy=TRUE,warning=FALSE}

weekly_lookback_2d_mse = vector("list", length(currencies))
weekly_lookback_2d_acc = vector("list", length(currencies))
names(weekly_lookback_2d_mse) = currencies
names(weekly_lookback_2d_acc) = currencies

for(curr in currencies){
  weekly_lookback_2d_mse[[curr]] = matrix(nrow = length(look_back), ncol = length(delta_grid))
  weekly_lookback_2d_acc[[curr]] = matrix(nrow = length(look_back), ncol = length(delta_grid))
  for(i in 1:length(look_back)){
    ts = append_moving_avg(weekly_data[[curr]],look_back[i]) 
    for(j in 1:length(delta_grid)){
    results = svm_linear(ts,c('maVol','maRet'),delta_grid[j]) 
    weekly_lookback_2d_mse[[curr]][i,j] = results[1]
    weekly_lookback_2d_acc[[curr]][i,j] = results[2]
    }
  }
}


```


Diagnostics for multidimensional problems
```{r,tidy = TRUE}



#table of cross currency optimal mses and which p and delta values generated them 



#diagonsitics for multidimensional problems
oneD_Ep_results = matrix(nrow = 6, ncol = length(currencies))
colnames(oneD_Ep_results) = currencies
rownames(oneD_Ep_results) = c('p_Daily','Delta_Daily','MSE_Daily', 'p_Weekly','Delta_Weekly','MSE_Weekly')


twoD_Ep_results = matrix(nrow = 6, ncol = length(currencies))
colnames(twoD_Ep_results) = currencies
rownames(twoD_Ep_results) = c('p_Daily','Delta_Daily','MSE_Daily', 'p_Weekly','Delta_Weekly','MSE_Weekly')


for(curr in currencies){ 
  index = which(daily_lookback_1d_mse[[curr]] == min(daily_lookback_1d_mse[[curr]]), arr.ind=TRUE)
  oneD_Ep_results['p_Daily',curr] = look_back[index[1,'row']]
  oneD_Ep_results['Delta_Daily',curr] = delta_grid[index[1,'col']]
  oneD_Ep_results['MSE_Daily',curr] = min(daily_lookback_1d_mse[[curr]])

  index = which(weekly_lookback_1d_mse[[curr]] == min(weekly_lookback_1d_mse[[curr]]), arr.ind=TRUE)
  oneD_Ep_results['p_Weekly',curr] = look_back[index[1,'row']]
  oneD_Ep_results['Delta_Weekly',curr] = delta_grid[index[1,'col']]
  oneD_Ep_results['MSE_Weekly',curr] = min(weekly_lookback_1d_mse[[curr]])

  index = which(daily_lookback_2d_mse[[curr]] == min(daily_lookback_2d_mse[[curr]]), arr.ind=TRUE)
  twoD_Ep_results['p_Daily',curr] = look_back[index[1,'row']]
  twoD_Ep_results['Delta_Daily',curr] = delta_grid[index[1,'col']]
  twoD_Ep_results['MSE_Daily',curr] = min(daily_lookback_2d_mse[[curr]])

  index = which(weekly_lookback_2d_mse[[curr]] == min(weekly_lookback_2d_mse[[curr]]), arr.ind=TRUE)
  twoD_Ep_results['p_Weekly',curr] = look_back[index[1,'row']]
  twoD_Ep_results['Delta_Weekly',curr] = delta_grid[index[1,'col']]
  twoD_Ep_results['MSE_Weekly',curr] = min(weekly_lookback_2d_mse[[curr]])
}

```



Aggregate results
```{r, tidy = T, warning=F}

setwd("~/Desktop/FIN580/hw3/Plots/AggResults")

name = 'Aggregate Performance of Linear SVM With Daily Volatility '
plot(daily_1d_cum_mse$Delta, daily_1d_cum_mse$MSE, xlab = 'Delta', ylab = 'MSE', main = name, pch = 21, bg = 'blue')
index = which.min(daily_1d_cum_mse$MSE)
points(daily_1d_cum_mse$Delta[index],daily_1d_cum_mse$MSE[index],pch = 21, bg = 'red')
dev.copy(pdf,paste(name,".pdf",sep=""))
dev.off()


name = 'Aggregate Accuracy of Linear SVM With Daily Volatility '
plot(daily_1d_cum_acc$Delta, daily_1d_cum_acc$Accuracy, xlab = 'Delta', ylab = 'Accuracy', main = name, pch = 21, bg = 'blue')
index = which.max(daily_1d_cum_acc$Accuracy)
points(daily_1d_cum_acc$Delta[index],daily_1d_cum_acc$Accuracy[index],pch = 21, bg = 'red')
dev.copy(pdf,paste(name,".pdf",sep=""))
dev.off()


name = 'Aggregate Performance of Linear SVM With Weekly Volatility '
plot(weekly_1d_cum_mse$Delta, weekly_1d_cum_mse$MSE, xlab = 'Delta', ylab = 'MSE', main = name, pch = 21, bg = 'blue')
index = which.min(weekly_1d_cum_mse$MSE)
points(weekly_1d_cum_mse$Delta[index],weekly_1d_cum_mse$MSE[index],pch = 21, bg = 'red')
dev.copy(pdf,paste(name,".pdf",sep=""))
dev.off()


name = 'Aggregate Accuracy of Linear SVM With Weekly Volatility '
plot(weekly_1d_cum_acc$Delta, weekly_1d_cum_acc$Accuracy, xlab = 'Delta', ylab = 'Accuracy', main = name, pch = 21, bg = 'blue')
index = which.max(weekly_1d_cum_acc$Accuracy)
points(weekly_1d_cum_acc$Delta[index],weekly_1d_cum_acc$Accuracy[index],pch = 21, bg = 'red')
dev.copy(pdf,paste(name,".pdf",sep=""))
dev.off()


name = 'Aggregate Performance of Two-Dimensional SVM With Daily Volatility '
plot(daily_2d_cum_mse$Delta, daily_2d_cum_mse$MSE, xlab = 'Delta', ylab = 'MSE', main = name, pch = 21, bg = 'blue')
index = which.min(daily_2d_cum_mse$MSE)
points(daily_2d_cum_mse$Delta[index],daily_2d_cum_mse$MSE[index],pch = 21, bg = 'red')
dev.copy(pdf,paste(name,".pdf",sep=""))
dev.off()


name = 'Aggregate Accuracy of Two-Dimensional SVM With Daily Volatility '
plot(daily_2d_cum_acc$Delta, daily_2d_cum_acc$Accuracy, xlab = 'Delta', ylab = 'Accuracy', main = name, pch = 21, bg = 'blue')
index = which.max(daily_2d_cum_acc$Accuracy)
points(daily_2d_cum_acc$Delta[index],daily_2d_cum_acc$Accuracy[index],pch = 21, bg = 'red')
dev.copy(pdf,paste(name,".pdf",sep=""))
dev.off()


name = 'Aggregate Performance of Two-Dimensional SVM With Weekly Volatility '
plot(weekly_2d_cum_mse$Delta, weekly_2d_cum_mse$MSE, xlab = 'Delta', ylab = 'MSE', main = name, pch = 21, bg = 'blue')
index = which.min(weekly_2d_cum_mse$MSE)
points(weekly_2d_cum_mse$Delta[index],weekly_2d_cum_mse$MSE[index],pch = 21, bg = 'red')
dev.copy(pdf,paste(name,".pdf",sep=""))
dev.off()


name = 'Aggregate Accuracy of Two-Dimensional SVM With Weekly Volatility '
plot(weekly_2d_cum_acc$Delta, weekly_2d_cum_acc$Accuracy, xlab = 'Delta', ylab = 'Accuracy', main = name, pch = 21, bg = 'blue')
index = which.max(weekly_2d_cum_acc$Accuracy)
points(weekly_2d_cum_acc$Delta[index],weekly_2d_cum_acc$Accuracy[index],pch = 21, bg = 'red')
dev.copy(pdf,paste(name,".pdf",sep=""))
dev.off()


#########################################################################################################################
#tables

make_table = function(data){
  results = matrix(nrow = length(delta_grid), ncol = length(currencies))
  rownames(results) = delta_grid
  colnames(results) = currencies
  for(j in 1:length(currencies)){
    indicies = which(data$Currency == currencies[j])  
    for(i in 1:length(delta_grid)){
     results[i,j] = data$MSE[indicies[i]] 
    }
  }
  return(results) 
}

table = make_table(daily_1d_results)
stargazer(table)

table = make_table(weekly_1d_results)
stargazer(table)

table = make_table(daily_2d_results)
stargazer(table)

table = make_table(weekly_2d_results)
stargazer(table)



best_daily = matrix(nrow = 4, ncol = length(currencies))
colnames(best_daily) = currencies
rownames(best_daily) = c('Vol','Vol+Ret','E_p Vol','E_p Vol+E_p Ret')

for(curr in currencies){
  indicies = which(daily_1d_results$Currency == curr)
  best_daily[1,curr] = min(daily_1d_results$MSE[indicies])
 
  indicies = which(daily_2d_results$Currency == curr)
  best_daily[2,curr] = min(daily_2d_results$MSE[indicies])
 
  best_daily[3,curr] = oneD_Ep_results['MSE_Daily',curr] 
 
  best_daily[4,curr] = twoD_Ep_results['MSE_Daily',curr]
}

stargazer(best_daily)

best_weekly= matrix(nrow = 4, ncol = length(currencies))
colnames(best_weekly) = currencies
rownames(best_weekly) = c('Vol','Vol+Ret','E_p Vol','E_p Vol+E_p Ret')

for(curr in currencies){
  indicies = which(weekly_1d_results$Currency == curr)
  best_weekly[1,curr] = min(weekly_1d_results$MSE[indicies])
 
  indicies = which(weekly_2d_results$Currency == curr)
  best_weekly[2,curr] = min(weekly_2d_results$MSE[indicies])
 
  best_weekly[3,curr] = oneD_Ep_results['MSE_Weekly',curr] 
 
  best_weekly[4,curr] = twoD_Ep_results['MSE_Weekly',curr]
}


stargazer(best_weekly)


pdf("oneD_results.pdf", height=11, width=30)
grid.table(oneD_Ep_results)
dev.off()

pdf("twoD_results.pdf", height=11, width=30)
grid.table(twoD_Ep_results)
dev.off()




```







#Logistic Regression Implementation
Data getting function for LR 
```{r,tidy=TRUE,warning=FALSE}

rm(list = ls())
load("daily_vols.RData")
load("weekly_vols.RData")
load("daily_rets.RData")
load("weekly_rets.RData")
load("currencies.RData")


#data name is "daily" or "weekly", i is numeric, train is 1 (for true) or 0 (for false), add_rt is also 1 (for true) or 0 (for false)
get_lr_data=function(data_name,i,train,add_rt){
  use_data=get(paste(data_name,"_vols",sep=""))
  use_data=use_data[[i]]
  t1_indices=which(use_data[,"Train"]==train)
  t_indices=t1_indices-1
  if(add_rt>0){
    rt=get(paste(data_name,"_rets",sep=""))
    rt=rt[[i]]
    ret_data=data.frame(matrix(cbind(use_data[t1_indices,"Vol"],use_data[t_indices,"Vol"],rt[t_indices,"Ret"]),ncol=3))
    colnames(ret_data)=c("t1","t","rt")
  }
  else{
    ret_data=data.frame(matrix(cbind(use_data[t1_indices,"Vol"],use_data[t_indices,"Vol"]),ncol=2))
    colnames(ret_data)=c("t1","t")
  }
  
  return(ret_data)
} 

#data name is "daily" or "weekly", i is numeric, train is 1 (for true) or 0 (for false), add_rt is also 1 (for true) or 0 (for false)
#p and q are for MA terms
get_lr_data_pq=function(data_name,i,train,add_rt,p,q){
  use_data=get(paste(data_name,"_vols",sep=""))
  use_data=use_data[[i]]
  t1_indices=which(use_data[,"Train"]==train)
  ept=sapply(t1_indices,function(i){
    start_i=max(i-p-2,0)+1
    return(mean(use_data[start_i:(i-1),"Vol"]))
  })
  if(add_rt>0){
    rt=get(paste(data_name,"_rets",sep=""))
    rt=rt[[i]]
    eqrt=sapply(t1_indices,function(i){
      start_i=max(i-q-2,0)+1
      return(mean(rt[start_i:(i-1),"Ret"]))
    })
    ret_data=data.frame(matrix(cbind(use_data[t1_indices,"Vol"],ept,eqrt),ncol=3))
    colnames(ret_data)=c("t1","ept","eqrt")
  }
  else{
    ret_data=data.frame(matrix(cbind(use_data[t1_indices,"Vol"],ept),ncol=2))
    colnames(ret_data)=c("t1","ept")
  }
  return(ret_data)
} 

```

Model fitting and mses
Logistic regression - Model 1
```{r,tidy=TRUE,warning=FALSE}
#Optimization of delta for logistic regression over training set
#Fit model for one currency for one delta
#New_data is for prediction
fit_lr=function(use_data,delta,new_data){
  y=sapply(seq(1,nrow(use_data),1), function(i){ 
    if(use_data[i,"t1"]/use_data[i,"t"]-1 >= delta){
      return(1)
    }
    else{
      return(0) #glm() uses 1 or 0 shouldnt matter since we already labeled y based on its being -1 or 1
    }})
  use_data=cbind(y,use_data,use_data[,"t"]*delta)
  colnames(use_data)=c(colnames(use_data[,1:3]),"t1del")
  model=glm(formula=as.formula("y~(t1-t)/(t1del)"),family=binomial(link="logit"),data=use_data)
  new_data=cbind(use_data,use_data[,"t"]*delta)
  pred_y=predict(model,type="response",newdata=new_data)
  pred_sigs=sapply(seq(1,length(y),1),function(i){
    if(round(y[i],0)==1){
      return(new_data[i,"t"]*(1+delta))
    }
    else{
      return(new_data[i,"t"]*(1-delta))
    }
  } )
  return(mse(pred_sigs,new_data[,"t1"]))
}

#Sequence of deltas to use
deltas=seq(0,0.15,length.out=10)
#Will save mse by delta by currency just in case we want to get fancy and plot that, but probs not gonna happen tbh 
mses_d=data.frame(matrix(NA,ncol=length(currencies),nrow=length(deltas)))
colnames(mses_d)=currencies
rownames(mses_d)=round(deltas,2)
mses_w=data.frame(matrix(NA,ncol=length(currencies),nrow=length(deltas)))
colnames(mses_w)=currencies
rownames(mses_w)=round(deltas,2)
#Daily - train
for(i in 1:length(currencies)){
  u_d=get_lr_data("daily",i,1,0)
  mses_d[,i]=sapply(deltas,function(x){fit_lr(u_d,x,u_d)}) #newdata = usedata=train
}

min_del_d=deltas[which.min(rowMeans(mses_d))]

#Weekly - train
for(i in 1:length(currencies)){
  u_d=get_lr_data("weekly",i,1,0)
  mses_w[,i]=sapply(deltas,function(x){fit_lr(u_d,x,u_d)}) #newdata = usedata=train
}
min_del_w=deltas[which.min(rowMeans(mses_w))]

stargazer(mses_d,summary=FALSE)
stargazer(mses_w,summary=FALSE)

#Plot MSES vs. Delta - training data
plot(deltas,rowMeans(mses_d),pch=23,col=2,main="Training MSE by Delta - Daily Vols",xlab="Delta",ylab="MSE over training data")
dev.copy(pdf,"lr_daily_train.pdf")
dev.off()
plot(deltas,rowMeans(mses_w),pch=2,col=3,main="Training MSE by Delta - Weekly Vols",xlab="Delta",ylab="MSE over training data")
dev.copy(pdf,"lr_weekly_train.pdf")
dev.off()

#Testing mses - we'll combine weekly and daily
mses_test=data.frame(matrix(NA,ncol=length(currencies)+1,nrow=2))
colnames(mses_test)=c(currencies,"Average")
rownames(mses_test)=c("Daily Testing","Weekly Testing")
for(i in 1:length(currencies)){
  u_d=get_lr_data("daily",i,1,0)
  n_d=get_lr_data("daily",i,0,0)
  mses_test[1,i]=fit_lr(u_d,min_del_d,n_d)
  u_d=get_lr_data("weekly",i,1,0)
  n_d=get_lr_data("weekly",i,0,0)
  mses_test[2,i]=fit_lr(u_d,min_del_w,n_d)
}
mses_test[,ncol(mses_test)]=rowMeans(mses_test[,1:9])
stargazer(t(mses_test),summary=FALSE,rownames=TRUE)

```


Logistic regression - Model 2
```{r,tidy=TRUE,warning=FALSE}
#Optimization of delta for logistic regression over training set
#Fit model for one currency for one delta
#New_data is for prediction
fit_lr_2=function(use_data,delta,new_data){
  y=sapply(seq(1,nrow(use_data),1), function(i){ 
    if((use_data[i,"t1"]-use_data[i,"rt"])/use_data[i,"t"]-1 >= delta){
      return(1)
    }
    else{
      return(0) #glm() uses 1 or 0 shouldnt matter since we already labeled y based on its being -1 or 1
    }})
  use_data=cbind(y,use_data,use_data[,"t"]*delta)
  colnames(use_data)=c(colnames(use_data[,1:4]),"t1del")
  model=glm(formula=as.formula("y~(t1-rt-t)/(t1del)"),family=binomial(link="logit"),data=use_data)
  new_data=cbind(use_data,use_data[,"t"]*delta)
  pred_y=predict(model,type="response",newdata=new_data)
  pred_sigs=sapply(seq(1,length(y),1),function(i){
    if(round(y[i],0)==1){
      return(new_data[i,"rt"]+new_data[i,"t"]*(1+delta))
    }
    else{
      return(new_data[i,"rt"]+new_data[i,"t"]*(1-delta))
    }
  } )
  return(mse(pred_sigs,new_data[,"t1"]))
}

#Sequence of deltas to use
deltas=seq(0,0.15,length.out=10)
#Will save mse by delta by currency just in case we want to get fancy and plot that, but probs not gonna happen tbh 
mses_d=data.frame(matrix(NA,ncol=length(currencies),nrow=length(deltas)))
colnames(mses_d)=currencies
rownames(mses_d)=round(deltas,2)
mses_w=data.frame(matrix(NA,ncol=length(currencies),nrow=length(deltas)))
colnames(mses_w)=currencies
rownames(mses_w)=round(deltas,2)
#Daily - train
for(i in 1:length(currencies)){
  u_d=get_lr_data("daily",i,1,1)
  mses_d[,i]=sapply(deltas,function(x){fit_lr_2(u_d,x,u_d)}) #newdata = usedata=train
}

min_del_d=deltas[which.min(rowMeans(mses_d))]

#Weekly - train
for(i in 1:length(currencies)){
  u_d=get_lr_data("weekly",i,1,1)
  mses_w[,i]=sapply(deltas,function(x){fit_lr_2(u_d,x,u_d)}) #newdata = usedata=train
}

min_del_w=deltas[which.min(rowMeans(mses_w))]

stargazer(mses_d,summary=FALSE)
stargazer(mses_w,summary=FALSE)

#Plot MSES vs. Delta - training data
plot(deltas,rowMeans(mses_d),pch=23,col=2,main="Forecaster 2: Training MSE by Delta - Daily Vols",xlab="Delta",ylab="MSE over training data")
dev.copy(pdf,"lr_daily_train_2.pdf")
dev.off()
plot(deltas,rowMeans(mses_w),pch=2,col=3,main="Forecaster 2: Training MSE by Delta - Weekly Vols",xlab="Delta",ylab="MSE over training data")
dev.copy(pdf,"lr_weekly_train_2.pdf")
dev.off()

#Testing mses - we'll combine weekly and daily
mses_test=data.frame(matrix(NA,ncol=length(currencies)+1,nrow=2))
colnames(mses_test)=c(currencies,"Average")
rownames(mses_test)=c("Daily Testing","Weekly Testing")
for(i in 1:length(currencies)){
  u_d=get_lr_data("daily",i,1,1)
  n_d=get_lr_data("daily",i,0,1)
  mses_test[1,i]=fit_lr(u_d,min_del_d,n_d)
  u_d=get_lr_data("weekly",i,1,0)
  n_d=get_lr_data("weekly",i,0,0)
  mses_test[2,i]=fit_lr(u_d,min_del_w,n_d)
}
mses_test[,ncol(mses_test)]=rowMeans(mses_test[,1:9])
stargazer(t(mses_test),summary=FALSE,rownames=TRUE)
```

Logistic regression - Model 3 
```{r,tidy=TRUE,warning=FALSE}
#Optimization of delta for logistic regression over training set
#Fit model for one currency for one delta
#New_data is for prediction
fit_lr_3=function(use_data,delta,new_data,p){
  y=sapply(seq(1,nrow(use_data),1), function(i){ 
    if((use_data[i,"t1"])/use_data[i,"ept"]-1 >= delta){
      return(1)
    }
    else{
      return(0) #glm() uses 1 or 0 shouldnt matter since we already labeled y based on its being -1 or 1
    }})
  use_data=cbind(y,use_data,use_data[,"ept"]*delta)
  colnames(use_data)=c(colnames(use_data[,1:3]),"eptdel")
  model=glm(formula=as.formula("y~(t1-ept)/(eptdel)"),family=binomial(link="logit"),data=use_data)
  new_data=cbind(use_data,use_data[,"ept"]*delta)
  pred_y=predict(model,type="response",newdata=new_data)
  pred_sigs=sapply(seq(1,length(y),1),function(i){
    if(round(y[i],0)==1){
      return(new_data[i,"ept"]*(1+delta))
    }
    else{
      return(new_data[i,"ept"]*(1-delta))
    }
  } )
  return(mse(pred_sigs,new_data[,"t1"]))
}

#Sequence of deltas to use
deltas=seq(0,0.15,length.out=10)
ps=c(3,5,10)
#Will save mse by delta by currency just in case we want to get fancy and plot that, but probs not gonna happen tbh 
#To save memory - I manually change p and re-run to avoid saving down too many new tables and crashing R
p=10
mses_d=data.frame(matrix(NA,ncol=length(currencies),nrow=length(deltas)))
colnames(mses_d)=currencies
rownames(mses_d)=round(deltas,2)
mses_w=data.frame(matrix(NA,ncol=length(currencies),nrow=length(deltas)))
colnames(mses_w)=currencies
rownames(mses_w)=round(deltas,2)
#Daily - train
for(i in 1:length(currencies)){
  u_d=get_lr_data_pq("daily",i,1,0,p,1) #q does't matter if no rt
  mses_d[,i]=sapply(deltas,function(x){fit_lr_3(u_d,x,u_d,p)}) #newdata = usedata=train
}

min_3_d=min(rowMeans(mses_d))
min_del_d_3=deltas[which.min(rowMeans(mses_d))]

min_5_d=min(rowMeans(mses_d))
min_del_d_5=deltas[which.min(rowMeans(mses_d))]

min_10_d=min(rowMeans(mses_d))
min_del_d_10=deltas[which.min(rowMeans(mses_d))]

#Weekly - train
for(i in 1:length(currencies)){
  u_d=get_lr_data_pq("weekly",i,1,0,p,1)
  mses_w[,i]=sapply(deltas,function(x){fit_lr_3(u_d,x,u_d,p)}) #newdata = usedata=train
}

min_3_w=min(rowMeans(mses_w))
min_del_w_3=deltas[which.min(rowMeans(mses_w))]

min_5_w=min(rowMeans(mses_w))
min_del_w_5=deltas[which.min(rowMeans(mses_w))]

min_10_w=min(rowMeans(mses_w))
min_del_w_10=deltas[which.min(rowMeans(mses_w))]

stargazer(mses_d,summary=FALSE)
stargazer(mses_w,summary=FALSE)

#Plot MSES vs. Delta - training data
plot(deltas,rowMeans(mses_d),pch=23,col=2,main="Forecaster 3: Training MSE by Delta - Daily Vols - p=10",xlab="Delta",ylab="MSE over training data")
dev.copy(pdf,"lr_daily_train_3_10.pdf")
dev.off()
plot(deltas,rowMeans(mses_w),pch=2,col=3,main="Forecaster 3: Training MSE by Delta - Weekly Vols - p=10",xlab="Delta",ylab="MSE over training data")
dev.copy(pdf,"lr_weekly_train_3_10.pdf")
dev.off()

#Testing mses - we'll combine weekly and daily into one table
p_opt_d=ps[which.min(c(min_3_d,min_5_d,min_10_d))] #p=5
del_opt_d=deltas[which.min(c(min_del_d_3,min_del_d_5,min_del_d_10))]
p_opt_w=ps[which.min(c(min_3_w,min_5_w,min_10_w))] #p=3
del_opt_w=deltas[which.min(c(min_del_w_3,min_del_w_5,min_del_w_10))]
mses_test=data.frame(matrix(NA,ncol=length(currencies)+1,nrow=2))
colnames(mses_test)=c(currencies,"Average")
rownames(mses_test)=c("Daily Testing p=5","Weekly Testing p=3")
for(i in 1:length(currencies)){
  u_d=get_lr_data_pq("daily",i,1,0,p_opt_d,1)
  n_d=get_lr_data_pq("daily",i,0,0,p_opt_d,1)
  mses_test[1,i]=fit_lr_3(u_d,del_opt_d,n_d,p_opt_d)
  u_d=get_lr_data_pq("weekly",i,1,0,p_opt_w,1)
  n_d=get_lr_data_pq("weekly",i,0,0,p_opt_w,1)
  mses_test[2,i]=fit_lr_3(u_d,del_opt_w,n_d,p_opt_w)
}
mses_test[,ncol(mses_test)]=rowMeans(mses_test[,1:9])
stargazer(t(mses_test),summary=FALSE,rownames=TRUE)

```

Logistic regression - Model 4
```{r,tidy=TRUE,warning=FALSE}
#Optimization of delta for logistic regression over training set
#Fit model for one currency for one delta
#New_data is for prediction
fit_lr_4=function(use_data,delta,new_data,p,q){
  y=sapply(seq(1,nrow(use_data),1), function(i){ 
    if((use_data[i,"t1"]-use_data[i,"eqrt"])/use_data[i,"ept"]-1 >= delta){
      return(1)
    }
    else{
      return(0) #glm() uses 1 or 0 shouldnt matter since we already labeled y based on its being -1 or 1
    }})
  use_data=cbind(y,use_data,use_data[,"ept"]*delta)
  colnames(use_data)=c(colnames(use_data[,1:4]),"eptdel")
  model=glm(formula=as.formula("y~(t1-eqrt-ept)/(eptdel)"),family=binomial(link="logit"),data=use_data)
  new_data=cbind(use_data,use_data[,"ept"]*delta)
  pred_y=predict(model,type="response",newdata=new_data)
  pred_sigs=sapply(seq(1,length(y),1),function(i){
    if(round(y[i],0)==1){
      return(new_data[i,"eqrt"]+new_data[i,"ept"]*(1+delta))
    }
    else{
      return(new_data[i,"eqrt"]+new_data[i,"ept"]*(1-delta))
    }
  } )
  return(mse(pred_sigs,new_data[,"t1"]))
}
#Note we will not be outputting all 18 combination of daily/weekly, ps , and qs just the optimal
#Optimizing
qs=ps
mses_d=data.frame(matrix(NA,ncol=length(currencies),nrow=length(deltas)))
colnames(mses_d)=currencies
rownames(mses_d)=round(deltas,2)
mses_w=data.frame(matrix(NA,ncol=length(currencies),nrow=length(deltas)))
colnames(mses_w)=currencies
rownames(mses_w)=round(deltas,2)
min_d=100000
min_w=100000

for(k in 1:length(ps)){
  print(paste("p",ps[k]))
  for(j in 1:length(qs)){
    print(paste("q",qs[j]))
    for(i in 1:length(currencies)){
      u_d=get_lr_data_pq("daily",i,1,1,ps[k],qs[j]) 
      mses_d[,i]=sapply(deltas,function(x){fit_lr_4(u_d,x,u_d,p,q)})
      u_d=get_lr_data_pq("weekly",i,1,1,ps[k],qs[j])
      mses_w[,i]=sapply(deltas,function(x){fit_lr_4(u_d,x,u_d,p,q)})
    }
    #Check for new min
    if(min(rowMeans(mses_d))<min_d){
      i_d=which.min(rowMeans(mses_d))
      del_opt_d=deltas[i_d]
      p_opt_d=ps[k]
      q_opt_d=qs[j]
      min_d=min(rowMeans(mses_d))
    }
    if(min(rowMeans(mses_w))<min_w){
      i_w=which.min(rowMeans(mses_w))
      del_opt_w=deltas[i_w]
      p_opt_w=ps[k]
      q_opt_w=qs[j]
      min_w=min(rowMeans(mses_w))
    }
  }
}

#Run on testing data w optimal parameters
mses_test=data.frame(matrix(NA,ncol=length(currencies)+1,nrow=2))
colnames(mses_test)=c(currencies,"Average")
rownames(mses_test)=c(paste("Daily Testing",round(del_opt_d,3),p_opt_d,q_opt_d),paste("Weekly Testing",round(del_opt_w,3),p_opt_w,q_opt_w))
for(i in 1:length(currencies)){
  u_d=get_lr_data_pq("daily",i,1,1,p_opt_d,q_opt_d)
  n_d=get_lr_data_pq("daily",i,0,1,p_opt_d,q_opt_d)
  mses_test[1,i]=fit_lr_4(u_d,del_opt_d,n_d,p_opt_d,q_opt_w)
  u_d=get_lr_data_pq("weekly",i,1,1,p_opt_w,q_opt_w)
  n_d=get_lr_data_pq("weekly",i,0,1,p_opt_w,q_opt_w)
  mses_test[2,i]=fit_lr_4(u_d,del_opt_w,n_d,p_opt_w,q_opt_w)
}
mses_test[,ncol(mses_test)]=rowMeans(mses_test[,1:9])
stargazer(t(mses_test),summary=FALSE,rownames=TRUE)





```