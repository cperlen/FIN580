---
title: "FIN580_HW3"
output: pdf_document
---

#installing needed packages
```{r, warning=FALSE,tidy=TRUE, message=FALSE }
#Setup 
library(e1071)
library(lubridate)
library(tidyverse)
library(gridExtra)
library(xlsx)
library(forecast)
library(tseries)
library(stats)
library(car)
library(glmnet)
library(miscTools)
library(Metrics)
library(knitr)
library(class)
library(vars)
library(BigVAR)
library(orderedLasso)
library(BioPhysConnectoR)

#Set seed
set.seed(1560)

```


Reading in and preprocessing data
```{r, warning=FALSE,tidy=TRUE, message=FALSE }

setwd("~/Desktop/FIN580/data")
load_data_from_scratch = F

if(load_data_from_scratch){
  file_names=dir(path="~/Desktop/FIN580/data",pattern = '.csv')
  currencies = strsplit(file_names[1:(length(file_names)-1)],'USD.csv')
  
  labels = read.csv(file_names[length(file_names)],header = T)
  labels[,1] = as.Date(labels[,1], origin = lubridate::origin )
  labels[nrow(labels),2] = 0 #not training on last day because do not have data to test fit
  colnames(labels)[1] = "Date"
  
  prices = lapply(file_names[1:length(currencies)], function(x) { 
    temp = read.csv(x ,header = T)
    temp = temp[,c("Date","Close")]
    if(x == "AUDUSD.csv"){
      temp$Date = as.Date(temp$Date, format = "%m/%d/%y",origin = lubridate::origin) #why it has a different format I have no idea
    }
    else{
      temp$Date = as.Date(temp$Date, format = "%m/%d/%Y",origin = lubridate::origin)
    }
    return(temp) })
  
  names(prices) = currencies
  dates = unique(labels[,1])
  
  #compute return series
  get_5min_rets = function(x){
    tot_rets = data.frame(Date=as.Date(character()), Returns = numeric())
    pos = 1
    for(i in 1:length(dates)){
      indicies = which(x[,1] == dates[i])
      if(length(indicies) != 0){
  
        daily_prices = x[indicies,2]
        daily_rets = log(daily_prices[2:length(daily_prices)]/daily_prices[1:(length(daily_prices)-1)])
        len = length(daily_rets)
        tot_rets[pos:(pos+len-1),] = list(rep(dates[i],length(daily_rets)),daily_rets)
        pos = pos + len
      }
    }
    return(tot_rets)
  }
  
  rets_5min = lapply(prices, get_5min_rets)
  
  get_daily_rets = function(x){
    rets = data.frame(Date=as.Date(character()), Ret = numeric(), Train = numeric() )
    pos = 1
    for(i in 1:length(dates)){
      indicies = which(x[,1] == dates[i])
      len = length(indicies)
      if(len != 0){
        ret = log(x[indicies[len],2]/x[indicies[1],2]) #return for the day is log(P_23:55/P_0:00)
        rets[pos,] = list(dates[i],ret, labels[which(labels$Date == dates[i]),2])
        pos = pos + 1
        }
    }
    return(rets)
  }
  
  daily_rets = lapply(prices, get_daily_rets)
  
  
  
  #compute volatility series

  get_daily_vols = function(x){

    vols = data.frame(Date=as.Date(character()), Vol = numeric(), Train = numeric() )
    pos = 1
    for(i in 1:length(dates)){
      indicies = which(x[,1] == dates[i])
      if(length(indicies) != 0){
          rets = x[indicies,2]
          vol = sqrt(252) * sd(rets) #annualize volatility
          if(vol != 0){ #get rid of days during which vol is 0
            vols[pos,] = list(dates[i],log(vol), labels[which(labels$Date == dates[i]),2])
            pos = pos + 1
        }
      }
    }
    return(vols)
  }
  
  daily_vols = lapply(rets_5min,get_daily_vols)
  
  
  #weekly statics
  dates_by_curr = lapply(daily_vols, function(x){ x$Date}) #which dates have non-zero vols
  
  
  
  get_weekly_vols = function(curr){
    x = rets_5min[[curr]]
    c_dates = dates_by_curr[[curr]]
    
    vols = data.frame(Date=as.Date(character()), Ret = numeric(), Train = numeric() )
    pos = 1
    for(i in 5:length(c_dates)){
      indicies = unique(unlist(sapply((i-4):i, function(j) { which(x[,1] == c_dates[j])})))
      if(length(indicies) != 0){
          rets = x[indicies,2]
          vol = sqrt(50) * sd(rets) #annualize volatility
          if(vol != 0){ #get rid of days during which vol is 0
            vols[pos,] = list(c_dates[i],log(vol), labels[which(labels$Date == c_dates[i]),2])
            pos = pos + 1
        }
      }
    }
    return(vols)
  }
  
  weekly_vols = lapply(currencies, get_weekly_vols)
  names(weekly_vols) = currencies
  
  
  
  get_weekly_rets = function(curr){
    x = prices[[curr]]
    c_dates = dates_by_curr[[curr]]
    
    rets = data.frame(Date=as.Date(character()), Ret = numeric(), Train = numeric() )
    pos = 1
    for(i in 5:length(c_dates)){
      indicies = unique(unlist(sapply((i-4):i, function(j) { which(x[,1] == c_dates[j])})))
      n = length(indicies)
      if(n != 0){
          ret = log(x[indicies[n],2] / x[indicies[1],2] )#last day close divided first day open
          rets[pos,] = list(c_dates[i],ret, labels[which(labels$Date == c_dates[i]),2]) 
          pos = pos + 1
        }
      }
    return(rets)
  }
  
  weekly_rets = lapply(currencies, get_weekly_rets)
  names(weekly_rets) = currencies
  
  save(weekly_rets, file = "weekly_rets.Rdata")
  save(daily_rets,file = "daily_rets.Rdata")
  save(daily_vols,file="daily_vols.RData")
  save(weekly_vols,file="weekly_vols.RData")
  save(currencies, file = "currencies.RData")
}

if(!load_data_from_scratch)  {
  load("daily_vols.RData")
  load("weekly_vols.RData")
  load("daily_rets.RData")
  load("weekly_rets.RData")
  load("currencies.RData")
}
  
  
```


#Support Vector Machine implementation: Work in progress I will handle.  Nina take care of logistic regression

```{r}
#intuition for choosing delta grid
train_indicies = which(daily_vols$AUD[,3] == 1)
AUDvols = daily_vols$AUD[,2]
delta = 0.0
for(i in 1:(length(train_indicies)-1)){
  index = train_indicies[i]
  if(AUDvols[index+1] >= AUDvols[index]){
    delta = delta + AUDvols[index+1]/ AUDvols[index] -1
  }
  else{
    delta = delta + 1 - AUDvols[index+1]/ AUDvols[index-1]
  }
}
delta / (length(train_indicies)-1)



#define grid
delta_grid = seq(-.1,.1,.2/25)

```



Fit daily svm
```{r}
#function for svm
get_labels=function(curr){
  training_index = train_indicies[[curr]]
  vol_series = daily_vols[[curr]][,2]
  labels = sapply(training_index, function(i){ 
    if(vol_series[i+1]/vol_series[i] -1 >= delta){
      return(1)
    }
    else{
      return(-1)
    }})
  return(labels)
}

#compute indices of trianing set
train_indicies = sapply(daily_vols,function(x) { which(x[,3] == 1)})
names(train_indicies) = currencies 


#helper function, fits svm to linear vols
delta <<- delta

svm_daily_linear = function(delta,curr){
  
  #computes labels (which depend on delta)
  vols = daily_vols[[curr]]
  train_indices = which(vols[,3] == 1)
  test_indices = which(vols[,3] == 0) 
  test_indicies = test_indicies[1:(length(test_indicies-1))] #do not include last date
  
  #generates model data sets
  train_labels = get_labels(curr) #codes +- 1
  y = as.factor(train_labels)
  x = daily_vols[[curr]][train_indicies,2]
  df = as.data.frame(cbind(x,y))
  names(df) = c("vol","label")
    
  #tune and fit svm 
  svm_tune = tune(svm, train.x=df$vol, train.y=df$label, kernel="linear", ranges=list(cost=10^(-1:2), gamma=c(.5,1,2)), type = 'C-classification')
  svm_model = svm(df$label ~ ., data=df,kernel="linear", cost = svm_tune$best.model$cost, gamma = svm_tune$best.model$gamma,type = 'C-classification')

  #regression model
  test_labels = predict(svm_models[[curr]], vols[test_indicies,2]) #svm prediction
  test_predictions = sapply(1:length(test_labels), function(i) {
    if (test_labels[i] == 1){
      return(vols[test_indicies[i]] * (1 + delta)) 
    }
    else{
      return(vols[test_indicies[i]] * (1 - delta)) 
    }
  })
  
  #compute mse
  return( mean( (test_predictions - vols[test_indicies+1,2])^2))
}


```

include plots of data in feature space
